import numpy as np
import scipy as sp
from .pareto_smooth import pareto_smooth

def _map_sample(f, draws):
    return np.apply_along_axis(f, arr=draws, axis=0)

def _to_simplex(log_weights):
    return np.exp(log_weights - sp.special.logsumexp(log_weights))


def is_weights(proposal, target, num_draws):
    """Return the specified number of draws and normalized importance sampling weights for the specified proposal and target distributions. 

    The proposal distribution needs to implement a `.sample()` method
    and a `log_density()` function for parameters and the target
    distribution needs to implement only `log_density()`.  The raw
    importance weights are the ratio of the target density to the
    proposal density, and hence must be positive.  The returned weights
    are the raw weights divided by the sum of the raw weights, which
    will be a unit simplex (non-negative values summing to one).
    
    Args:
        proposal:  The proposal distribution implementing sampling and log density methods.
        target:  The target distribution implementing a log density method.
        num_draws: The number of draws to return.

    Return:
        The pair (draws, weights) consisting of the draws and importance sampling weights. 
    """
    draws = [proposal.sample() for _ in range(num_draws)]
    log_p = _map_sample(target.log_density, draws)
    log_q = _map_sample(proposal.log_density, draws)
    weights = _to_simplex(log_p - log_q)
    return draws, weights


def is_expect(draws, weights, f):
    """Return the expectation of the function f given the specified draws and importance sampling weights. 

    Args:
        draws: The draws from the approximate distribution.
        weights: Importance weights for target distribution and approximate distribution.
        f: The function for which an expectation is being computed.

    Return: 
        The expectation of f given the specified draws and importance sampling weights.
    """
    return (_map_sample(f, draws) * weights).sum(axis=-1)

def importance_sample(proposal, target, num_draws, f):
    """Return an importance sampling estimate of the expectation of the specified function in the target distribution, using the specified proposal distribution and number of draws. 

    Args:
        proposal: Proposal distribution implementing sampling and log density methods.
        target: Target distribution implementing a log density method.
        num_draws: Number of draws to use for the estimate.
        f: Function whose expectation is being estimated.

    Return:
       The importance sample estimate of the expectation of f in the target distribution.
    """
    draws, weights = is_weights(proposal, target, num_draws)
    return is_expect(draws, weights, f)

def importance_resample(proposal, target, pool_size, num_draws):
    """Return a sample of the specified number of draws by drawing a pool from proposal distribution and then importance resampling with probabilities proportional to importance weights.

    This method is called sampling importance resampling (SIR) in statistics.

    Args:
        proposal: A proposal distribution implementing sampling and log density methods.
        target: A target distribution implementing a log density method.
        pool_size: The number of draws from proposal distribution.
        num_draws: The number of draws to return.
    
    Return:
        A sequence of draws of the specified size generated by importance resampling.
    """
    pool, weights = is_weights(proposal, target, pool_size)
    counts = np.random.multinomial(num_draws, weights)
    return np.repeat(pool, counts, axis=0)

def is_weights_ps(proposal, target, num_draws):
    """Return the specified number of draws and normalized Pareto-smoothed importance sampling weights for the specified proposal and target distribution along with the Pareto smoothed weights and estimate of the k parameter.

    This is similar to `is_weights`, but further applies Pareto smoothing to the weights. 
    See `pareto_smooth()` function for information on how the smoothing is applied.

    See `is_weights()` for the unsmoothed version.

    Args:
        proposal:  The proposal distribution implementing sampling and log density methods.
        target:  The target distribution implementing a log density method.
        num_draws: The number of draws to return.

    Return:
        The pair (draws, weights, k_hat) consisting of the draws, importance sampling weights, and estimate of k.
    """    
    draws, weights = is_weights(proposal, target, num_draws)
    smoothed_weights, kappa = pareto_smooth(weights)
    return draws, smoothed_weights, kappa

def importance_sample_ps(proposal, target, num_draws, f):
    """Return a Pareto-smoothed importance sampling estimate of the expectation of the specified function in the target distribution, using the specified proposal distribution and number of draws and the estimate of the k parameter.

    See `importance_sample()` for the unsmoothed version.

    Args:
        proposal: Proposal distribution implementing sampling and log density methods.
        target: Target distribution implementing a log density method.
        num_draws: Number of draws to use for the estimate.
        f: Function whose expectation is being estimated.

    Return:
       The pair (draws, kappa) with the importance sample estimate of the expectation and the estimate of k.
    """
    draws, weights, kappa = is_weights_ps(proposal, target, num_draws)
    return is_expect(draws, weights, f), kappa


def importance_resample_ps(proposal, target, pool_size, num_draws):
    """Return a sample of the specified number of draws by drawing a pool from proposal distribution and then Pareto-smoothed importance resampling with probabilities proportional to importance weights.

    See `importance_resample()` for the unsmoothed version.

    Args:
        proposal: A proposal distribution implementing sampling and log density methods.
        target: A target distribution implementing a log density method.
        pool_size: The number of draws from proposal distribution.
        num_draws: The number of draws to return.
    
    Return:
        A sequence of draws of the specified size generated by importance resampling.
    """
    pool, weights, kappa = is_weights_ps(proposal, target, pool_size)
    counts = np.random.multinomial(num_draws, weights)
    return np.repeat(pool, counts, axis=0), kappa
